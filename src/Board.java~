public class Board {

	int [][] holes;
	/*
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * the board is represented as a 2d array
	 * empty spots are occupied by -1's and non-empty spots are occupied by the respective numbers
	 */

	/**
	 * 
	 * *** When would we throw that exception...?
	 * @param b
	 * @throws NullBoardException
	 */
	public Board(int[][] b) throws NullBoardException {
		holes = b;
	}

	/**
	 * ***Any other elaborate things I should do...?
	 * ***Create an instance of Board
	 */
	public Board() {
		//Initialize the holes array:
		holes = new int[9][9];
	}

	/**
	 * Generates next board states the simple way outlined
	 * in the assignment
	 * @return
	 * @throws NullBoardException
	 */
	public Board [] getChildren() throws NullBoardException { //TODO: have to check if it is already solved
		if (!validBoardState()) {
			throw new NullBoardException("This board does not have children because it is invalid.");
		}
		
		int firstrow= -1; //row of first unfilled square
		int firstcol= -1; //column of first unfilled square
		int totalvalid= 0; //total number of valid boards

		for (int row = 8; row > -1; row--) {
			for (int col = 8; col > -1; col--) {
				if (holes[row][col] == -1) {
					firstrow = row;
					firstcol = col;
				}
			}
		}
		
		Board[] totalBoards = new Board[10];
		//[totalBoards has an array size 10 with all values initialized to null]
		
		//First fill the array with all 
		for (int i = 0; i < 9; i++) {
			totalBoards[i] = cloneBoard();
		}

		for (int i = 1; i < 10; i++) {
			totalBoards[i-1].fill(firstrow,firstcol,i);
			//make an array of all possible children, including invalid boards
			if (totalBoards[i-1].validBoardState()) {
				totalvalid++;
			}
		}

		Board [] validBoards = new Board[totalvalid];
		for (int j = 0; j < 9; j++) {
			Board temp = totalBoards[j];
			if (temp.validBoardState()) {
				validBoards[totalvalid-1] = totalBoards[j];//make an array of all valid children boards
				totalvalid = totalvalid-1;
			}
		}

		return validBoards;
	}
	
	/**
	 * Generates next board states in a more intelligent way.
	 * @return
	 * @throws NullBoardException
	 */
	public Board [] getIntelligentChildren() throws NullBoardException{
		return null;
	}

	/**
	 * ***Like this or something more elaborate...?
	 * fill the hole at (x,y) with the value n
	 * @param x
	 * @param y
	 * @param n
	 */
	public void fill(int row, int col, int n) {
		holes[row][col] = n;
	}

	/**
	 * ***Put in cases where if row or col > 9 then fail it?
	 * ***What does col/row mean - row 1 = first row in the three/three scene?
	 * check if the 3*3 sub-square contains the specified val
	 * @param col
	 * @param row
	 * @param val
	 * @return
	 */
	public boolean checkSubsquare(int col, int row, int val) {
		int r = row/3 * 3; //Integer division so we get row number this subsquare is on.
		int c = col/3 * 3; //Integer division so we get the top left column of the subsquare.
		for (int a = 0; a < 3; a++) {
			for (int b = 0; b < 3; b++) {
				if (holes[r + a][c + b] == val) { return false; }
			}
		}
		
		//[Not found in the subsquare]
		return true;
	}
	
	
	/**
	 * ***Returns true if the subsquare has n in it and false otherwise
	 * ***There are nine subsquares numbered zero through eight from the top left to the right, then one row down and repeat
	 * @param SS
	 * @param n
	 * @return
	 */
	public boolean checkSubsquareDuplicate(int SS, int n) {
		int r = SS/3 * 3;
		int c = SS%3 * 3;
		int count = 0; //How many cells in this subsquare have the value
		for (int a = 0; a < 3; a++) {
			for (int b = 0; b < 3; b++) {
				if (holes[r+a][c+b] == n) { count++; }
				if (count == 2) {
					return true;
				} //There is a duplicate
			}
		}
		//[No duplicate entry of n found in this subsquare]
		return false;
	}
	
	/**
	 * ***Returns true if this subsquare has a duplicate of any number 1-9 and false otherwise
	 * @param SS
	 * @return
	 */
	public boolean checkSubsquareDuplicate(int SS) {
		for (int i = 1; i < 10; i++) {
			if (checkSubsquareDuplicate(SS, i)) { return true; }
		}
		
		//[No duplicate numbers 1-9 found in every subsquare]
		return false;
	}

	/**
	 * ***Returns true if any subsquare has a duplicate of any number 1-9 and false otherwise
	 * @return
	 */
	public boolean checkSubsquareDuplicate() {
		for (int i = 0; i < 9; i++) {
			if (checkSubsquareDuplicate(i)) { return true; }
		}
		
		//[No duplicate entries 1-9 found in every subsquare]
		return false;
	}
	
	/**
	 * ***So I am assuming that the user will put less than 9 in for c
	 * to check if the same row has already contained the number n
	 * @param row
	 * @par am c
	 * @param n
	 * @return
	 */
	public boolean checkRow(int row, int c, int n) {
		while (c < 9) {
			if (holes[row][c] == n) {
				return true;
			}
			c++;
		}
		return false;
	}


	/**
	 * ***Returns true if there is a duplicate of n in the row, false otherwise
	 * @param row
	 * @param n
	 * @return
	 */
	public boolean checkRowDuplicate(int row, int n) {
		//Search each column in row 'row'
		for (int c = 0; c < 9; c++) {
			if (holes[row][c] == n) {
				c++;
				//Check the remaining columns
				while (c < 9) {
					if (holes[row][c] == n) { return true; }
					c++;
				}
			}
		}

		//[No duplicates found]
		return false;
	}


	/**
	 * ***Ditto about the rows
	 * to check if the same column has already contained the number n
	 * @param col
	 * @param r
	 * @param n
	 * @return
	 */
	public boolean checkColumn(int col, int r, int n) {
		while (r < 9) {
			if (holes[r][col] == n) { return false; }
			r++;
		}
		return true;
	}

	/**
	 * ***Returns true if there is a duplicate of n in the column, false otherwise
	 * @param row
	 * @param n
	 * @return
	 */
	public boolean checkColumnDuplicate(int col, int n) {
		//Search each column in row 'row'
		for (int r = 0; r < 9; r++) {
			if (holes[r][col] == n) {
				r++;
				//Check the remaining columns
				while (r < 9) {
					if (holes[r][col] == n) { return true; }
					r++;
				}
			}
		}

		//[No duplicates found]
		return false;
	} 


	/**
	 * ^^^With valid numbers...? --> Piazza 166 says just checks if it is full of numbers
	 * check if the game board holes are all filled with numbers
	 * @return 
	 */
	public boolean ifFull() {
		for (int i = 0; i < 9; i++) {
			if (checkRow(i, 0, -1)) { return false; } //Check each row for -1; found if we find it in the row
			if (checkColumn(i, 0, -1)) { return false; } //Check each column for -1; found if we find it in the column *** Redundant, isn't it? Delete line!
		}
		return true; //Return true if all values are filled in
	}

	/**
	 * Checks if board state is valid, for whatever degree of filled it is.
	 * @return
	 */
	public boolean validBoardState() {

		//Check for duplicates in each subsquare
		if (checkSubsquareDuplicate()) {
			return false;
		}
		
		//Check for duplicates in each row and column
		for (int i = 0; i < 9; i++) {
			for (int w = 1; w < 10; w++) {
				if (checkRowDuplicate(i, w)) { return false; }
				if (checkColumnDuplicate(i, w)) { return false; }
			}
		}

		//Checks if either the cell is -1 or a number 1-9 else return false
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				if (!(holes[i][j] >= 1) || !(holes[i][j] <= 9)) {
					//[This number is either below 0 or above 9]
					if (holes[i][j] == -1) { break; } //Hey, it's -1, so we cool.
					return false;
				}
			}
		}

		//[Either -1 or values from 1-9 are in each cell]
		
		return true;
	}


	/**
	 * check if the board is in its goal position
	 * @return
	 */
	public boolean ifGoal() {

		if (!ifFull()) { return false; } //[Board still has holes]

		if (!validBoardState()) { return false; } //[Not valid state]
		
		//[We've reached the goal stage!]
		return true;
	}


	/**
	 * make a deep copy of the current board
	 * @return
	 * @throws NullBoardException 
	 */
	public Board cloneBoard() throws NullBoardException {
		int [][] holesDuplicate;
		holesDuplicate = new int [9][9];
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				holesDuplicate[i][j] = holes[i][j];
			}
		}
		return new Board(holesDuplicate); //Make a new board with the same holes array as this instance.
	}

	/**
	 * print the array representation of this board
	 */
	public void printBoard() {
		String out = "";
		for (int r = 0; r < 9; r ++) {
			String row = "";
			for (int c =0; c <9; c++) {
				row = row + this.holes[r][c]; 
			}
			out = out+ (row + "\n");
		}
		System.out.println(out);
	}

	/**
	 * Check if the input board b is a valid board
	 * @param b
	 * @return
	 */
	boolean checkBoard(int[][] b) {
		return false;
	}



}

public class Board {

	int [][] holes;
	/*
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * *** *** ***
	 * the board is represented as a 2d array
	 * empty spots are occupied by -1's and non-empty spots are occupied by the respective numbers
	 */

	/**
	 * 
	 * @param b
	 * @throws NullBoardException
	 */
	public Board(int[][] b) throws NullBoardException {
		if (b == null || !checkBoard(b)) { throw new NullBoardException("This array is not valid."); }
		holes = b;
	}

	/**
	 * Creates a new instance of Board with a 9x9 array.
	 */
	public Board() {
		holes = new int[9][9];
	}

	/**
	 * Generates next board states the simple way outlined
	 * in the assignment
	 * @return A board with all possible valid children of this Board
	 * @throws NullBoardException
	 */
	public Board [] getChildren() throws NullBoardException {
		if (!validBoardState()) {
			throw new NullBoardException("This board does not have children because it is invalid.");
		}
		int firstrow = -1;//row of first unfilled square
		int firstcol = -1;//column of first unfilled square
		int totalvalid = 0;//total number of valid boards

		for (int row = 8; row > -1; row = row - 1) {
			for (int col = 8; col > -1; col = col - 1){
				if(holes[row][col] == -1){
					firstrow = row;
					firstcol = col;
				}
			}
		}

		if (firstrow == -1) {
			throw new NullBoardException("There are no children.");
		}

		Board[] totalBoards= new Board[9];

		for (int i = 0; i < 9; i++){
			totalBoards[i] = cloneBoard(); //Make totalBoards an array of clones
		}

		for(int i= 1;i<10;i++){
			totalBoards[i-1].fill(firstrow, firstcol, i);
			//make an array of all possible children, including invalid boards
			if(totalBoards[i-1].validBoardState()){
				totalvalid++;
			}
		}

		Board [] validBoards = new Board[totalvalid];
		for(int j = 0; j < 9; j++){
			Board temp = totalBoards[j];
			if(temp.validBoardState()){
				validBoards[totalvalid-1] = totalBoards[j];//make an array of all valid children boards
				totalvalid= totalvalid-1;
			}
		}

		return validBoards;
	}

	/**
	 * 
	 * @param board
	 * @return A 9 by 9 array in which each element is the number of possible children that would be yielded from filling in
	 * the corresponding square on the Sudoku Board 'board' - if the square is already filled in on the board, it is considered
	 * to have 0 children.
	 */
	public int [][] numChildrenArray(Board board){
		int[][] childrenArray = new int[9][9];

		for(int row = 0; row < 9; row++){
			for(int col = 0; col < 9; col++){
				int holevalue= board.holes[row][col];
				if(holevalue! = -1){
					//If the square in the board at [row][col] is not empty, fill the corresponding square in numChildrenArray with 0
					childrenArray[row][col]= 0;
				}
				else{
					int numChildren = getNumChildren(board, row, col);
					//Set the square at childrenArray[row][col] with the number of children it has
					childrenArray[row][col] = numChildren;
				}
			}
		}

		return childrenArray;
	}

	/**
	 * Precondition: board.holes[row][col]==-1
	 * Returns the number of valid children boards generated by filling in square [row][col] on Board board.
	 * @param board The board which will have a square filled in.
	 * @param row The row of the square to be filled in.
	 * @param col The column of the square to be filled in.
	 * @return Returns the number of valid children boards generated if [row][col] is filled in on board.
	 */
	public int getNumChildren(Board board, int row, int col){
		int validChildren = 0;

		for(int i= 1; i < 10; i++){
			board.holes[row][col] = i;
			if(board.validBoardState()) {
				//If [row][col] is set to i and the new board is valid, add one to validChildren.
				validChildren++;
			}
		}

		board.holes[row][col] = -1; //Reset the square at [row][col] to what it was originally (-1)
		return validChildren;
	}

	/**
	 * Precondition: numChildrenArray is a 9 by 9 array, with the maximum value of any cell being 9 and the minimum value 0
	 * Returns the index of the lowest value that is greater than zero in the 9 by 9 array in the form of a catenated
	 * string with the first character as the index of the row, second character as the index of the column, and the
	 * rest of the string as the value in the indexed square.
	 * @param numChildrenArray Two-dimensional array of integers
	 * @return The catenated string as described above.
	 */
	public String indexLowestChildren(int[][] numChildrenArray) {
		int rowIndex = -1;
		int colIndex = -1;
		int lowestValue= 10;
		for(int row = 8; row > -1; row = row - 1){
			for(int col = 8; col > -1; col = col-  1){
				if(numChildrenArray[row][col] <= lowestValue && numChildrenArray[row][col] > 0){
					rowIndex= row;
					colIndex= col;
					//If the number of children at [row][col] is less than or equal to lowestValue, make it the new lowest value
					lowestValue= numChildrenArray[row][col];
				}
			}
		}
		//If there is no cell with a value between 1 and 9, return "-1-110"
		return "" + rowIndex + colIndex + lowestValue;
	}

	/**
	 * Generates next board states in a more intelligent way.
	 * @return A board array as described above
	 * @throws NullBoardException
	 */
	public Board [] getIntelligentChildren() throws NullBoardException {
		int[][] childrenArray = numChildrenArray(this);
		String indexLowestValue = indexLowestChildren(childrenArray);
		if (indexLowestValue.equals("-1-110")) { //There are no children if this is returned
			return new Board[0];
		}
		int lowestRow= Integer.parseInt(indexLowestValue.substring(0,1));
		int lowestCol= Integer.parseInt(indexLowestValue.substring(1,2));
		int numChildren= Integer.parseInt(indexLowestValue.substring(2));

		Board[] allChildren= new Board[9];//Array for all possible children, valid and invalid
		Board[] childBoards= new Board[numChildren];//Array for only valid children

		for (int i = 1; i < 10; i++) {
			allChildren[i-1]= cloneBoard();
			allChildren[i-1].fill(lowestRow, lowestCol,i);
			//make an array of all possible children, including invalid boards
		}
		for (int i = 0; i < 9; i++) {
			if (allChildren[i].validBoardState()) {
				childBoards[numChildren-1]= allChildren[i];//make an array of only valid children
				numChildren = numChildren - 1;
			}
		}
		return childBoards;
	}

	/**
	 * fill the hole at (row,col) with the value n
	 * @param row Row of hole
	 * @param col Column of hole
	 * @param n Value to fill in the hole
	 */
	public void fill(int row, int col, int n) {
		holes[row][col] = n;
	}

	/**
	 * check if the 3*3 sub-square contains the specified val other than at (row, col)
	 * @param col Column of the subsquare we are checking
	 * @param row Row of the subsquare we are checking
	 * @param val Value to look for
	 * @return True if the subsquare has the value, false otherwise
	 */
	public boolean checkSubsquare(int col, int row, int val) {
		int r = row/3 * 3; //Integer division so we get row number this subsquare is on.
		int c = col/3 * 3; //Integer division so we get the top left column of the subsquare.
		for (int a = 0; a < 3; a++) {
			for (int b = 0; b < 3; b++) {
				if (holes[r + a][c + b] == val && r + a != row && c + b != col) { return false; }
			}
		}
		//[Not found in the subsquare]
		return true;
	}


	/**
	 * Returns true if the subsquare has a duplicate value, n, in it and false otherwise
	 * There are nine subsquares numbered zero through eight from the top left to the right, then one row down and repeat
	 * @param SS Subsquare we are looking for duplicates in - the top left represents 0 and then it increments by each row.
	 * @param n Value we are looking for
	 * @return True if the subsquare has a duplicate value, n, in it and false otherwise
	 */
	public boolean checkSubsquareDuplicate(int SS, int n) {
		int r = SS/3 * 3;
		int c = SS%3 * 3;
		int count = 0; //How many cells in this subsquare have the value
		for (int a = 0; a < 3; a++) {
			for (int b = 0; b < 3; b++) {
				if (holes[r+a][c+b] == n) { count++; }
				if (count == 2) {
					return true;
				} //There is a duplicate
			}
		}
		//[No duplicate entry of n found in this subsquare]
		return false;
	}

	/**
	 * Returns true if this subsquare has a duplicate of any number 1-9 and false otherwise
	 * @param SS Subsquare we are looking for duplicates in - the top left represents 0 and then it increments by each row.
	 * @return True if this subsquare has a duplicate of any number 1-9 and false otherwise
	 */
	public boolean checkSubsquareDuplicate(int SS) {
		for (int i = 1; i < 10; i++) {
			if (checkSubsquareDuplicate(SS, i)) { return true; }
		}
		//[No duplicate numbers 1-9 found in every subsquare]
		return false;
	}

	/**
	 * Returns true if any subsquare has a duplicate of any number 1-9 and false otherwise
	 * @return true if any subsquare has a duplicate of any number 1-9 and false otherwise
	 */
	public boolean checkSubsquareDuplicate() {
		for (int i = 0; i < 9; i++) {
			if (checkSubsquareDuplicate(i)) { return true; }
		}
		//[No duplicate entries 1-9 found in every subsquare]
		return false;
	}

	/**
	 * to check if the same row has already contained the number n
	 * @param row Row to search for n
	 * @param c Column to start at
	 * @param n Value to search for
	 * @return True if the row, starting at column c, contains n
	 */
	public boolean checkRow(int row, int c, int n) {
		for (int i = 0; i < 9; i++) {
			if (holes[row][i] == n && i != c) {
				return false;
			}
		}
		return true;
	}

	/**
	 * to check if the row contains the number n
	 * @param row Row to search for n
	 * @param c Column to start at
	 * @param n Value to search for
	 * @return True if the row, starting at column c, contains n
	 */
	public boolean checkRowTwo(int row, int c, int n) {
		while (c < 9) {
			if (holes[row][c] == n) {
				return false;
			}
			c++;
		}
		return true;
	}


	/**
	 * Returns true if there is a duplicate of n in the row, false otherwise
	 * @param row Row to check for n
	 * @param n Value to search for
	 * @return True if there is a duplicate of n in the row, false otherwise
	 */
	public boolean checkRowDuplicate(int row, int n) {
		//Search each column in row 'row'
		for (int c = 0; c < 9; c++) {
			if (holes[row][c] == n) {
				c++;
				//Check the remaining columns
				while (c < 9) {
					if (holes[row][c] == n) { return true; }
					c++;
				}
			}
		}
		//[No duplicates found]
		return false;
	}


	/**
	 * 
	 * to check if the same column has already contained the number n
	 * @param col Column to search for n
	 * @param r Row to start at
	 * @param n Value to search for
	 * @return True if the column, starting at row r, contains n
	 */
	public boolean checkColumn(int col, int r, int n) {
		for (int i = 0; i < 9; i++) {
			if (holes[i][col] == n && i != r) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Returns true if there is a duplicate of n in the column, false otherwise
	 * @param col Column to start for n
	 * @param n value to search for
	 * @return True if there is a duplicate of n in column col, false otherwise.
	 */
	public boolean checkColumnDuplicate(int col, int n) {
		//Search each column in row 'row'
		for (int r = 0; r < 9; r++) {
			if (holes[r][col] == n) {
				r++;
				//Check the remaining columns
				while (r < 9) {
					if (holes[r][col] == n) { return true; }
					r++;
				}
			}
		}
		//[No duplicates found]
		return false;
	} 


	/**
	 *
	 * check if the game board holes are all filled with numbers
	 * @return True if the board contains no holes, false otherwise.
	 */
	public boolean ifFull() {
		for (int i = 0; i < 9; i++) {
			if (!checkRowTwo(i, 0, -1)) { return false; } //Check each row for -1; found if we find it in the row
		}
		return true; //Return true if all values are filled in
	}

	/**
	 * Checks if board state is valid, for whatever degree of filled it is.
	 * @return True if the board is valid otherwise false.
	 */
	public boolean validBoardState() {

		//Check for duplicates in each subsquare
		if (checkSubsquareDuplicate()) {
			return false;
		}

		//Check for duplicates in each row and column
		for (int i = 0; i < 9; i++) {
			for (int w = 1; w < 10; w++) {
				if (checkRowDuplicate(i, w)) { return false; }
				if (checkColumnDuplicate(i, w)) { return false; }
			}
		}

		//Checks if either the cell is -1 or a number 1-9 else return false
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				if ((holes[i][j] < 1 || holes[i][j] > 9) && holes[i][j] != -1) { return false; }
			}
		}
		//[Either -1 or values from 1-9 are in each cell]
		return true;
	}


	/**
	 * check if the board is in its goal position
	 * @return True if the board is in its goal position and false otherwise.
	 */
	public boolean ifGoal() {
		if (!ifFull()) { return false; } //Checks if it has holes

		if (!validBoardState()) { return false; } //Checks if it is in a valid state

		return true;
	}


	/**
	 * make a deep copy of the current board
	 * @return A new instance of Board that has the same array holes as this one.
	 * @throws NullBoardException 
	 */
	public Board cloneBoard() throws NullBoardException {
		int [][] holesDuplicate;
		holesDuplicate = new int [9][9];
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				holesDuplicate[i][j] = holes[i][j];
			}
		}
		return new Board(holesDuplicate); //Make a new board with the same holes array as this instance.
	}

	/**
	 * print the array representation of this board
	 */
	public void printBoard() {
		String out = "";
		for (int r = 0; r < 9; r ++) {
			String row = "";
			for (int c =0; c <9; c++) {
				row = row + this.holes[r][c]; 
			}
			out = out+ (row + "\n");
		}
		System.out.println(out);
	}

	/**
	 * Check if the input board b is a valid board.
	 * Checks to see if the board is null, has nine rows and columns, and that there are no 0s.
	 * @param b
	 * @return False if the board is not valid otherwise true.
	 */
	boolean checkBoard(int[][] b) {
		if (b == null) { return false; }
		if (b.length != 9) { return false; }
		for (int i = 0; i < 9; i++) {
			if (b[i].length != 9) { return false; }
		}
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				if (b[i][j] == 0) { return false; }
			}
		}
		return true;
	}
}
